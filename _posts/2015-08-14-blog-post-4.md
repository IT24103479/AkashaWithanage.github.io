---
title: 'Building a Smart Yahtzee AI: Implementing a Two-Player Game in C'
date: 2024-11-27
permalink: /posts/2015/08/yahtzee-game-ai/
tags:
  - programming
  - game development
  - C language
  - artificial intelligence
  - student project
---

Last semester, I took on an exciting challenge in my Programming Methodology course: implementing a two-player Yahtzee game in C with one key twist – the second player would be a computer opponent with actual strategy. Here's what I built and what I learned along the way.

## The Project Vision

Yahtzee is that classic dice game we've all played – roll five dice, try to make specific combinations, and score points over thirteen rounds. My task was to create a simplified version where a human player competes against a computer opponent that doesn't just make random moves, but actually thinks strategically.

## How the Computer Thinks

The real challenge wasn't just making the game work – it was making the computer play smart. Here's how I approached it:

### Strategic Dice Keeping
The computer prioritizes high-value, consistent scoring opportunities:
- **Small and Large Straights** come first (sequential dice like 1-2-3-4 or 1-2-3-4-5)
- **Full House** (three of one number, two of another) is next in line
- Only then does it focus on matching numbers for Three of a Kind or Four of a Kind

I implemented a **flag system** to keep the computer focused. Once it starts pursuing a straight, it won't suddenly switch to trying for matching numbers in the same turn. This prevents it from chasing conflicting strategies.

### Smart Category Selection
The computer follows a clear hierarchy:
1. Fixed-score categories (Straights, Full House, Yahtzee) if available
2. Highest-scoring available category otherwise
3. Any available category by turn three (even scoring zero) to keep the game moving

### Realistic Probability Awareness
Interestingly, the computer actually *deprioritizes* Yahtzee (five of a kind) despite it being the highest-scoring category. Why? Because in real Yahtzee, getting five matching dice is incredibly rare. The computer recognizes this and focuses on more achievable high scores instead.

## Challenges I Faced (and How I Solved Them)

### Making the Computer "Think" Like a Player
Creating dice-keeping logic that mimics human strategy was tricky. My solution? The flag system mentioned above. Once `straightskeeping` or `mostcountedkeeping` flags are set, the computer stays committed to that strategy for the turn.

### Balancing High Scores with Realistic Play
The computer needed to aim high but not be unrealistically perfect. I created a scoring hierarchy that lets it pursue the best available option while having fallback strategies for when luck isn't on its side.

### Keeping the Interface Clean
A complex game needs a clear interface. I implemented a scoreboard that updates each turn, showing both players' scores and highlighting which categories have been used. This keeps the human player informed without overwhelming them.

## What Worked Well

**Modular Design Saved the Day**
By breaking the game into reusable functions – `scoreboard()`, `category()`, `rollingdice()` – I could share code between human and computer players. This made development faster and debugging easier.

**The Computer Actually Puts Up a Fight**
During testing, the computer consistently scored in the 150-250 point range (decent for Yahtzee!), making it a legitimate opponent rather than just a placeholder.

## What's Not in This Version (And Why)

### No Dice Replacement After Keeping
Once you keep a die, it stays kept for the rest of your turn. Adding replacement would have required significantly more complex logic for the computer to reevaluate its strategy mid-turn.

### No Backtracking Between Phases
You can't return to dice-keeping once you move to category selection. While this limits flexibility, it keeps the game flow simple and prevents endless "just one more roll" scenarios.

### No Bonus Scoring
Traditional Yahtzee has bonuses for the upper section (ones through sixes) and extra Yahtzees. These weren't implemented to keep the project scope manageable for the assignment.

## Looking Forward: What I'd Add Next

If I were to continue this project, I'd focus on:

1. **Smarter Computer Strategy** – Tracking which categories haven't been scored yet and adjusting dice-keeping to specifically target them
2. **Clickable Dice Interface** – Moving beyond text input to actual dice clicking
3. **Flexible Dice Management** – Allowing players to "un-keep" dice between rolls
4. **Full Bonus System** – Implementing the traditional Yahtzee bonus rules

## Final Thoughts

This project was more than just coding a game – it was an exercise in creating artificial decision-making. The most satisfying moment? Watching the computer pass up a low-scoring Three of a Kind to pursue a (successful!) Large Straight attempt.

The code reminds me that good game AI isn't about being perfect – it's about being believably strategic, making reasonable choices, and occasionally getting lucky (or unlucky) with the dice, just like a human player would.

---

*This project was submitted as part of SE1012 Programming Methodology. The complete report is available upon request.*